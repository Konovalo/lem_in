/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   valid_seq.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kchaozu <kchaozu@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2019/12/07 15:47:45 by kchaozu           #+#    #+#             */
/*   Updated: 2019/12/07 16:53:29 by kchaozu          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf.h"

/*
** Определение "валидности" поданного преобразования.
** Валидность условная, так как неопредеенное поведение различается
** в зависимости от системной библиотеки оригинала.
** Данная реализация пытается вывести преобразование даже в случае
** некоректной последовательности допустимых символов (см. ниже).
** Пример некорректной последовательности "%###..10.1.###0llx".
** В случае если в преобразовании встретится недопустимый символ,
** преобразование считается простой строкой и выводится как есть,
** без учёта поданных аргументов.
*/

/*
** Является ли поданный символ допустимым (модификатором преобразования).
**
** Возврат: 0 - символ не является модификатором, код символа если
** является.
*/

static int	isconv(char c)
{
	return (c == 'x' || c == 'f' || c == 'c' || c == 's' || c == 'o' ||\
	c == 'u' || c == 'e' || c == 'i' || c == 'd' || c == 'b' || c == 'p' ||\
	c == 'j' || c == '%');
}

/*
** Является ли поданный символ допустимым (модификатором размера).
**
** Возврат: 0 - символ не является модификатором, код символа если
** является.
*/

static int	islenmodif(const char **mdf)
{
	if (!ft_strncmp(*mdf, "ll", 2) || !ft_strncmp(*mdf, "hh", 2))
		*mdf += 2;
	else if (**mdf == 'l' || **mdf == 'h' || **mdf == 'j' || **mdf == 'z'\
	|| **mdf == 'L')
		(*mdf)++;
	return (isconv(ft_tolower(**mdf)));
}

/*
** Определение валидности строки.
**
** Возврат: указатель на строку разбора если преобразование допутимо,
** NULL если нет.
*/

char		*valid_seq(const char *str)
{
	while (get_flags(*str))
		str++;
	while (ft_isdigit(*str))
		str++;
	if ((*str == '*' || *str == '.') && !get_flags(*(str - 1)) &&\
	!ft_isdigit(*(str - 1)) && *(str - 1) != '%')
		return (NULL);
	if (*str == '*')
		str++;
	if (*str == '.')
		str++;
	if (*str == '*')
	{
		str++;
		if (ft_isdigit(*str))
			return (NULL);
	}
	else
		while (ft_isdigit(*str))
			str++;
	if (!islenmodif(&str))
		return (NULL);
	return ((char *)str);
}
